# PHP7 Dependency Injector

[![Build Status](https://travis-ci.org/oliver-schoendorn/dependency-injector.svg?branch=master)](https://travis-ci.org/oliver-schoendorn/dependency-injector)
[![Coverage Status](https://coveralls.io/repos/github/oliver-schoendorn/dependency-injector/badge.svg?branch=master)](https://coveralls.io/github/oliver-schoendorn/dependency-injector?branch=master)

## Installation

`composer require oliver-schoendorn/dependency-injector`

Don't forget to include the composer autoloader in your application bootstrap process.

```php
require_once __DIR__  . "/vendor/autoload.php";
```

## Basic Usage

I recommend creating a single instance of the dependency injector during your applications bootstrap or request dispatching process.

The most common use case is to use the dependency injector to create instances of your controllers. In the following
example, the dependency injector is used to create an instance of `FakeController` and to invoke the `get` method of it.
All method parameters will be autowired. 

```php
<?php

/**
 * Class FakeController
 * This is a mock controller to show case the most common dependency injection use case
 */
class FakeController
{
    /**
     * @var FakeEntityRepository 
     */
    private $entityRepository;
    
    public function __construct(FakeEntityRepository $entityRepository)
    {
        $this->entityRepository = $entityRepository;
    }
    
    public function get(int $entityId)
    {
        $entity = $this->entityRepository->findById($entityId);
        return $entity->toJSON();
    }
}


// Somewhere in your bootstrap or dispatching process 
use OS\DependencyInjector\DependencyInjector;
use OS\DependencyInjector\ReflectionHandler;

$reflectionHandler = new ReflectionHandler();
$dependencyInjector = new DependencyInjector($reflectionHandler);

// This is just a mock and will likely be generated by your application / framework
$fakeRequestPayload = [ 'entityId' => 123 ];
$fakeRouteHandler   = [ FakeController::class, 'get' ];

function dispatchRequest(
    string $routeControllerClassId,
    string $routeControllerMethod,
    array $requestPayload
) use ($dependencyInjector) {
    // The dependency injector (DI) will create an instance of the given controller class id
    // In this specific example, the DI will attempt to autoload the FakeEntityRepository and inject it into the
    // controller constructor. 
    $controllerInstance = $dependencyInjector->resolve($routeControllerClassId);
    
    // After creating the controller instance, the $routeControllerMethod on the $controllerInstance will be called.
    // The DI will apply the necessary parameters, as long as they are present in the $requestPayload array or if it
    // can be autowired (for example if the get method requires an additional Repository instance for a related entity). 
    return $dependencyInjector->invoke([ $controllerInstance, $routeControllerMethod ], $requestPayload);
}

echo dispatchRequest($fakeRouteHandler[0], $fakeRouteHandler[1], $fakeRequestPayload);

```

## Dealing with shared instances

Some dependencies should only have a single instance (or as few as possible), like a database connection for instance.

````php
<?php

use OS\DependencyInjector\DependencyInjector;
use OS\DependencyInjector\ReflectionHandler;

interface DatabaseConnection { /* ... */ }
class PdoDatabaseConnection implements DatabaseConnection
{
    public function __construct(string $dsn, string $username, string $password, array $options = []) { /* ... */ }
    /* ... */
}

$di = new DependencyInjector(new ReflectionHandler());

// This line will tell the DI to substitute requests to
// DatabaseConnection::class with instances of PdoDatabaseConnection::class
$di->alias(DatabaseConnection::class, PdoDatabaseConnection::class);

// Next we will create an instance of the PdoDatabaseConnection::class
$di->share(new PdoDatabaseConnection('mysql:...', 'username', 'password', []));


// Now, when every the DI is asked for an instance of DatabaseConnection::class or PdoDatabaseConnection::class, it
// will return the same instance as defined above
$pdoDatabaseConnection = $di->resolve(DatabaseConnection::class);
````

### Handling multiple connections (simple)

Sometimes you have to deal with multiple database connections for example. The following example shows how to deal
with multiple shared instances of the same class or interface.

Note however, that this approach will not work with auto wiring and also break the type hinting in PhpStorm.

```php
<?php

use OS\DependencyInjector\DependencyInjector;
use OS\DependencyInjector\ReflectionHandler;

$di = new DependencyInjector(new ReflectionHandler());

// Prepare the two different database connection wrappers
$di->share(new PdoDatabaseConnection('mysql:...', 'username1', 'password1', []), 'mysql_read');
$di->share(new PdoDatabaseConnection('mysql:...', 'username2', 'password2', []), 'mysql_write');


// Getting the different connection wrappers
$readConnection = $di->resolve('mysql_read');
$writeConnection = $di->resolve('mysql_write');
```

### Handling multiple connections (verbose)

To circumvent the issues of the previous approach, you could define two additional interface that will be 
substituted by the read or write connection: 

```php
<?php

use OS\DependencyInjector\DependencyInjector;
use OS\DependencyInjector\ReflectionHandler;

$di = new DependencyInjector(new ReflectionHandler());

interface DatabaseReadConnection extends DatabaseConnection {}
interface DatabaseWriteConnection extends DatabaseConnection {}

// Prepare the two different database connection wrappers
$di->share(new PdoDatabaseConnection('mysql:...', 'username1', 'password1', []), DatabaseReadConnection::class);
$di->share(new PdoDatabaseConnection('mysql:...', 'username2', 'password2', []), DatabaseWriteConnection::class);


// Getting the different connection wrappers
$readConnection  = $di->resolve(DatabaseReadConnection::class);
$writeConnection = $di->invoke(function (DatabaseWriteConnection $connection) {
    /* ... */
});
```


## Building complex instance

### Approach 1: Predefine constructor arguments

```php
<?php

use OS\DependencyInjector\DependencyInjector;
use OS\DependencyInjector\ReflectionHandler;

$di = new DependencyInjector(new ReflectionHandler());

class ComplexClass
{
    public function __constructor(array $config, string $foo) { /* ... */ }
} 

$di->configure(ComplexClass::class, [ 'config' => [ 'fancy' => 'variables' ] ]);

```

## Old
```php
<?php

use OS\DependencyInjector\DependencyInjector;
use OS\DependencyInjector\ReflectionHandler;
use OS\DependencyInjector\Test\_support\Helper\TestClass01;

$reflectionHandler = new ReflectionHandler();
$dependencyInjector = new DependencyInjector($reflectionHandler);

// Basic class resolving (+ passing an argument)
$instance = $dependencyInjector->resolve(TestClass01::class, [ 'optional' => 'some value']);
assert($instance->constructorArgument === 'some value');

// Resolve dependencies
class SomeClassWithDependencies
{
    public $someOtherClass;
    public function __construct(SomeOtherClass $someOtherClass) {
        $this->someOtherClass = $someOtherClass;
    }
}

class SomeOtherClass
{
    
}

$instance = $dependencyInjector->resolve(SomeClassWithDependencies::class);
assert($instance->someOtherClass instanceof SomeOtherClass);

// Alias
$dependencyInjector->alias(SomeOtherClass::class, SomeClassWithDependencies::class);
$instance = $dependencyInjector->resolve(SomeClassWithDependencies::class);
assert($instance instanceof SomeOtherClass);

// Configure
class YetAnotherClass extends SomeOtherClass
{
    
}

$dependencyInjector->configure(SomeClassWithDependencies::class, [ ':someOtherClass' => YetAnotherClass::class ]);
$instance = $dependencyInjector->resolve(SomeClassWithDependencies::class);
assert($instance->someOtherClass instanceof YetAnotherClass);

// Delegate
class ClassWithSetters
{
    public $logger;
    public function setLogger(Psr\Log\LoggerInterface $logger)
    {
        $this->logger = $logger;
    }
}

// -> the parameters of the delegate method will get resolved by the dependency injector
$delegate = function(Monolog\Logger $logger): SomeClassWithDependencies
{
    $instance = new ClassWithSetters();
    $instance->setLogger($logger);
    return $instance;
};

$dependencyInjector->delegate(ClassWithSetters::class, $delegate);
$instance = $dependencyInjector->resolve(ClassWithSetters::class);
assert($instance->logger instanceof Monolog\Logger);

```